# C++ Module 09 - STL Algorithms and Advanced Data Structures

## 概要

C++ Module 09では、STLの高度な機能とアルゴリズムを学びます。

- **STLアルゴリズム**: ソート、検索、変換などの汎用的な操作
- **高度なデータ構造**: 複雑なデータの管理と操作
- **パフォーマンス最適化**: 効率的なアルゴリズムの実装と選択

このモジュールを通じて、C++の標準ライブラリの真の力を理解し、高性能で保守性の高いコードを書けるようになります。

---

## ルール

- C++98準拠で開発すること
- `-Wall -Wextra -Werror -std=c++98` オプションを用いてコンパイル
- STLの使用が許可される
- `printf`, `malloc`, `free` などのC関数は禁止
- `using namespace` や `friend` の使用も禁止
- メモリリークを避けること

---

## 各課題の概要

### ex00 - Bitcoin Exchange

**概要**:  
CSVファイルからビットコインの価格データを読み込み、日付と金額に基づいて価値を計算するプログラム。

**実装内容**:
- CSVファイルの解析とデータベースの構築
- 日付形式の検証と変換
- 価格データの検索と計算
- エラーハンドリング（無効な日付、価格データなしなど）

**技術的ポイント**:
- ファイル入出力の処理
- 文字列解析とデータ変換
- STLコンテナ（`map`, `vector`）の活用
- 例外処理とエラーメッセージ

---

### ex01 - RPN Calculator

**概要**:  
逆ポーランド記法（RPN）の計算機を実装し、スタックベースの計算を学ぶ。

**実装内容**:
- スタックデータ構造の実装
- 数値と演算子の解析
- 四則演算の実行
- エラーハンドリング（ゼロ除算、無効な演算子など）

**技術的ポイント**:
- スタックの実装と操作
- 文字列解析とトークン化
- 演算子の優先順位の処理
- 数値の精度管理

---

### ex02 - PmergeMe

**概要**:  
Ford-Johnson（merge-insertion）ソートアルゴリズムを実装し、`vector`と`deque`の両方でパフォーマンスを比較する。

**実装内容**:
- Ford-Johnsonソートアルゴリズムの実装
- `vector`と`deque`でのソート実行
- 実行時間の計測と比較
- 比較回数のカウント

**技術的ポイント**:
- 高度なソートアルゴリズムの実装
- 時間計測とパフォーマンス分析
- 異なるコンテナでのアルゴリズムの比較
- メモリ使用量の最適化

---

## STLアルゴリズムの詳細

### ソートアルゴリズム

**基本ソート**:
- `sort`: クイックソートベースの汎用ソート
- `stable_sort`: 安定ソート（同値要素の順序を保持）
- `partial_sort`: 部分ソート（上位N個のみソート）

**特殊ソート**:
- `nth_element`: N番目の要素を正しい位置に配置
- `heap_sort`: ヒープソート
- `merge`: 2つのソート済み範囲をマージ

### 検索アルゴリズム

**線形検索**:
- `find`: 値の検索
- `find_if`: 条件に合う要素の検索
- `count`: 値の出現回数

**二分検索**:
- `binary_search`: 二分検索
- `lower_bound`: 下限の位置
- `upper_bound`: 上限の位置

### 変換アルゴリズム

**要素の変換**:
- `transform`: 各要素に関数を適用
- `replace`: 値の置換
- `fill`: 範囲を値で埋める

---

## 技術的詳細

### Ford-Johnsonソートアルゴリズム

Ford-Johnson（merge-insertion）ソートは、比較回数を最小化するソートアルゴリズムです：

1. **ペア化**: 要素をペアに分け、各ペアで大小比較
2. **再帰ソート**: 大きい方の要素を再帰的にソート
3. **挿入**: 小さい方の要素を適切な位置に挿入

### パフォーマンス比較

```cpp
// vectorでのソート
std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6};
std::sort(vec.begin(), vec.end());

// dequeでのソート
std::deque<int> deq = {3, 1, 4, 1, 5, 9, 2, 6};
std::sort(deq.begin(), deq.end());
```

---

## ビルドと実行方法

各課題はそれぞれのディレクトリにあり、独自のMakefileが含まれています。

### ex00 - Bitcoin Exchange

```bash
cd ex00
make
./btc data.csv
```

### ex01 - RPN Calculator

```bash
cd ex01
make
./RPN "8 9 * 9 - 9 - 9 - 4 - 1 +"
```

### ex02 - PmergeMe

```bash
cd ex02
make
./PmergeMe 3 5 9 7 4
```

---

## アルゴリズムの選択指針

### ソートアルゴリズムの選択

- **小さいデータ**: 挿入ソート
- **一般的な用途**: クイックソート（`std::sort`）
- **安定性が必要**: マージソート（`std::stable_sort`）
- **部分ソート**: `std::partial_sort`

### 検索アルゴリズムの選択

- **未ソートデータ**: 線形検索（`std::find`）
- **ソート済みデータ**: 二分検索（`std::binary_search`）
- **範囲検索**: `std::lower_bound`, `std::upper_bound`

---

## パフォーマンス最適化

1. **適切なアルゴリズムの選択**: 時間計算量の考慮
2. **メモリ使用量の最適化**: 空間計算量の考慮
3. **キャッシュ効率**: データの局所性の活用
4. **並列処理**: 可能な場合の並列化

---

## 注意事項

- アルゴリズムの時間・空間計算量を理解すること
- メモリ使用量の監視
- 例外安全性の確保
- エッジケースの処理

---

## 学習目標

このモジュールを通じて以下を習得します：

1. **高度なアルゴリズム**: 複雑なソート・検索アルゴリズムの実装
2. **パフォーマンス分析**: アルゴリズムの効率性の評価
3. **データ構造の選択**: 用途に応じた最適なデータ構造の選択
4. **STLの活用**: 標準ライブラリの高度な機能の使用
5. **最適化技術**: コードの効率性を向上させる技術